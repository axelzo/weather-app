{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, initializeComponentRef } from '../../Utilities';\nimport { TextField } from '../../TextField';\nimport { ColorRectangle } from './ColorRectangle/ColorRectangle';\nimport { ColorSlider } from './ColorSlider/ColorSlider'; // These imports are separated to help with bundling\n\nimport { MAX_COLOR_ALPHA, MAX_COLOR_HUE, MAX_COLOR_RGB, MAX_HEX_LENGTH, MAX_RGBA_LENGTH, MIN_HEX_LENGTH, MIN_RGBA_LENGTH, HEX_REGEX, RGBA_REGEX } from '../../utilities/color/consts';\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { getColorFromRGBA } from '../../utilities/color/getColorFromRGBA';\nimport { updateA } from '../../utilities/color/updateA';\nimport { updateH } from '../../utilities/color/updateH';\nimport { correctRGB } from '../../utilities/color/correctRGB';\nimport { correctHex } from '../../utilities/color/correctHex';\nvar getClassNames = classNamesFunction();\nvar colorComponents = ['hex', 'r', 'g', 'b', 'a'];\n/**\n * {@docCategory ColorPicker}\n */\n\nvar ColorPickerBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ColorPickerBase, _super);\n\n  function ColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._onSVChanged = function (ev, color) {\n      _this._updateColor(ev, color);\n    };\n\n    _this._onHChanged = function (ev, h) {\n      _this._updateColor(ev, updateH(_this.state.color, h));\n    };\n\n    _this._onAChanged = function (ev, a) {\n      _this._updateColor(ev, updateA(_this.state.color, Math.round(a)));\n    };\n\n    _this._onBlur = function (event) {\n      var _a;\n\n      var _b = _this.state,\n          color = _b.color,\n          editingColor = _b.editingColor;\n\n      if (!editingColor) {\n        return;\n      } // If there was an intermediate incorrect value (such as too large or empty), correct it.\n\n\n      var value = editingColor.value,\n          component = editingColor.component;\n      var isHex = component === 'hex';\n      var minLength = isHex ? MIN_HEX_LENGTH : MIN_RGBA_LENGTH;\n\n      if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n        // Real value. Clamp to appropriate length (hex) or range (rgba).\n        var newColor = void 0;\n\n        if (isHex) {\n          newColor = getColorFromString('#' + correctHex(value));\n        } else {\n          newColor = getColorFromRGBA(correctRGB(tslib_1.__assign({}, color, (_a = {}, _a[component] = Number(value), _a))));\n        } // Update state and call onChange\n\n\n        _this._updateColor(event, newColor);\n      } else {\n        // Intermediate value was an empty string, too short (hex only), or just . (alpha only).\n        // Just clear the intermediate state and revert to the previous value.\n        _this.setState({\n          editingColor: undefined\n        });\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      color: _getColorFromProps(props) || getColorFromString('#ffffff')\n    };\n    _this._textChangeHandlers = {};\n\n    for (var _i = 0, colorComponents_1 = colorComponents; _i < colorComponents_1.length; _i++) {\n      var component = colorComponents_1[_i];\n      _this._textChangeHandlers[component] = _this._onTextChange.bind(_this, component);\n    }\n\n    _this._textLabels = {\n      r: props.redLabel,\n      g: props.greenLabel,\n      b: props.blueLabel,\n      a: props.alphaLabel,\n      hex: props.hexLabel\n    };\n    return _this;\n  }\n\n  Object.defineProperty(ColorPickerBase.prototype, \"color\", {\n    get: function () {\n      return this.state.color;\n    },\n    enumerable: true,\n    configurable: true\n  }); // tslint:disable-next-line function-name\n\n  ColorPickerBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    var color = _getColorFromProps(newProps);\n\n    if (color) {\n      this._updateColor(undefined, color);\n    }\n  };\n\n  ColorPickerBase.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var theme = props.theme,\n        className = props.className,\n        styles = props.styles;\n    var color = this.state.color;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, React.createElement(\"div\", {\n      className: classNames.panel\n    }, React.createElement(ColorRectangle, {\n      color: color,\n      onChange: this._onSVChanged\n    }), React.createElement(ColorSlider, {\n      className: \"is-hue\",\n      minValue: 0,\n      maxValue: MAX_COLOR_HUE,\n      value: color.h,\n      onChange: this._onHChanged\n    }), !props.alphaSliderHidden && React.createElement(ColorSlider, {\n      className: \"is-alpha\",\n      isAlpha: true,\n      overlayStyle: {\n        background: \"linear-gradient(to right, transparent 0, #\" + color.hex + \" 100%)\"\n      },\n      minValue: 0,\n      maxValue: MAX_COLOR_ALPHA,\n      value: color.a,\n      onChange: this._onAChanged\n    }), React.createElement(\"table\", {\n      className: classNames.table,\n      cellPadding: \"0\",\n      cellSpacing: \"0\"\n    }, React.createElement(\"thead\", null, React.createElement(\"tr\", {\n      className: classNames.tableHeader\n    }, React.createElement(\"td\", {\n      className: classNames.tableHexCell\n    }, props.hexLabel), React.createElement(\"td\", null, props.redLabel), React.createElement(\"td\", null, props.greenLabel), React.createElement(\"td\", null, props.blueLabel), !props.alphaSliderHidden && React.createElement(\"td\", null, props.alphaLabel))), React.createElement(\"tbody\", null, React.createElement(\"tr\", null, colorComponents.map(function (comp) {\n      if (comp === 'a' && props.alphaSliderHidden) {\n        return null;\n      }\n\n      return React.createElement(\"td\", {\n        key: comp,\n        style: comp === 'hex' ? undefined : {\n          width: '18%'\n        }\n      }, React.createElement(TextField, {\n        className: classNames.input,\n        onChange: _this._textChangeHandlers[comp],\n        onBlur: _this._onBlur,\n        value: _this._getDisplayValue(comp),\n        spellCheck: false,\n        ariaLabel: _this._textLabels[comp]\n      }));\n    }))))));\n  };\n\n  ColorPickerBase.prototype._getDisplayValue = function (component) {\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor;\n\n    if (editingColor && editingColor.component === component) {\n      return editingColor.value;\n    }\n\n    return String(color[component] || '');\n  };\n\n  ColorPickerBase.prototype._onTextChange = function (component, event, newValue) {\n    var _a;\n\n    var color = this.state.color;\n    var isHex = component === 'hex';\n    var isAlpha = component === 'a';\n    newValue = (newValue || '').substr(0, isHex ? MAX_HEX_LENGTH : MAX_RGBA_LENGTH); // Ignore what the user typed if it contains invalid characters\n\n    var validCharsRegex = isHex ? HEX_REGEX : RGBA_REGEX;\n\n    if (!validCharsRegex.test(newValue)) {\n      return;\n    } // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n\n\n    var isValid;\n\n    if (newValue === '') {\n      // Empty string is obviously not valid\n      isValid = false;\n    } else if (isHex) {\n      // Technically hex values of length 3 are also valid, but committing the value here would\n      // cause it to be automatically converted to a value of length 6, which may not be what the\n      // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n      isValid = newValue.length === MAX_HEX_LENGTH;\n    } else if (isAlpha) {\n      isValid = Number(newValue) <= MAX_COLOR_ALPHA;\n    } else {\n      isValid = Number(newValue) <= MAX_COLOR_RGB;\n    }\n\n    if (!isValid) {\n      // If the new value is an empty string or other invalid value, save that to display.\n      // (if the user still hasn't entered anything on blur, the last value is restored)\n      this.setState({\n        editingColor: {\n          component: component,\n          value: newValue\n        }\n      });\n    } else if (String(color[component]) === newValue) {\n      // If the new value is the same as the current value, mostly ignore it.\n      // Exception is that if the user was previously editing the value (but hadn't yet entered\n      // a new valid value), we should clear the intermediate value.\n      if (this.state.editingColor) {\n        this.setState({\n          editingColor: undefined\n        });\n      }\n    } else {\n      // Should be a valid color. Update the value.\n      var newColor = isHex ? getColorFromString('#' + newValue) : getColorFromRGBA(tslib_1.__assign({}, color, (_a = {}, _a[component] = Number(newValue), _a)));\n\n      this._updateColor(event, newColor);\n    }\n  };\n  /**\n   * Update the displayed color and call change handlers if appropriate.\n   * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n   * @param newColor - Updated color\n   */\n\n\n  ColorPickerBase.prototype._updateColor = function (ev, newColor) {\n    var _this = this;\n\n    if (!newColor) {\n      return;\n    }\n\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor;\n    var isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n\n    if (isDifferentColor || editingColor) {\n      this.setState({\n        color: newColor,\n        editingColor: undefined\n      }, function () {\n        if (ev && _this.props.onChange) {\n          _this.props.onChange(ev, newColor);\n        }\n      });\n    }\n  };\n\n  ColorPickerBase.defaultProps = {\n    hexLabel: 'Hex',\n    redLabel: 'Red',\n    greenLabel: 'Green',\n    blueLabel: 'Blue',\n    alphaLabel: 'Alpha'\n  };\n  return ColorPickerBase;\n}(React.Component);\n\nexport { ColorPickerBase };\n\nfunction _getColorFromProps(props) {\n  var color = props.color;\n  return typeof color === 'string' ? getColorFromString(color) : color;\n}","map":null,"metadata":{},"sourceType":"module"}